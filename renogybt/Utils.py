# Utility helpers for parsing data and calculating values.

import json
import os

# Reads data from a list of bytes, and converts to an int
def bytes_to_int(bs, offset, length, signed = False, scale = 1):
        ret = 0
        if len(bs) < (offset + length):
            return ret
        if length > 0:
            byteorder='big'
            start = offset
            end = offset + length
        else:
            byteorder='little'
            start = offset + length + 1
            end = offset + 1
        return round(int.from_bytes(bs[start:end], byteorder = byteorder, signed = signed) * scale, 2)

# Converts an integer into 2 bytes (16 bits)
# Returns either the first or second byte as an int
def int_to_bytes(i, pos = 0):
    if pos == 0:
        return int(format(i, '016b')[:8], 2)
    if pos == 1:
        return int(format(i, '016b')[8:], 2)
    return 0

def parse_temperature(raw_value, unit):
    sign = raw_value >> 7
    celcius = -(raw_value - 128) if sign == 1 else raw_value
    return format_temperature(celcius, unit)

def format_temperature(celcius, unit = 'F'):
    normalized = unit.strip().upper()
    return (celcius * 9 / 5) + 32 if normalized == 'F' else celcius

def filter_fields(data, fields_str):
    fields = [x.strip() for x in fields_str.split(',')] if len(fields_str) > 0 else [] # trim spaces
    if len(fields) > 0 and set(fields).issubset(data):
        return {key: data[key] for key in fields}
    return data

def add_calculated_values(data):
    if 'voltage' in data and 'current' in data:
        try:
            data.setdefault('power', round(data['voltage'] * data['current'], 2))
        except TypeError:
            pass
    if 'remaining_charge' in data and 'capacity' in data:
        try:
            if data['capacity']:
                level = (data['remaining_charge'] / data['capacity']) * 100
                data.setdefault('battery_level', round(level, 2))
        except TypeError:
            pass
    return data

def update_energy_totals(data, interval_sec, file_path='energy_totals.json', alias=None):
    """Update stored energy totals based on current voltage and current.

    The totals are persisted in *file_path* as JSON and keyed by *alias* so
    multiple devices can be tracked independently. The function also injects the
    updated totals back into ``data``.
    """
    if 'voltage' not in data or 'current' not in data:
        return
    try:
        voltage = float(data['voltage'])
        current = float(data['current'])
    except (TypeError, ValueError):
        return

    alias_key = alias or 'default'
    try:
        with open(file_path, 'r') as fp:
            totals_map = json.load(fp)
    except (OSError, json.JSONDecodeError):
        totals_map = {}

    totals = totals_map.get(alias_key, {'energy_in_kwh': 0, 'energy_out_kwh': 0})

    power_w = voltage * current
    delta_kwh = power_w * interval_sec / 3600
    if current >= 0:
        totals['energy_in_kwh'] = round(totals.get('energy_in_kwh', 0) + delta_kwh, 3)
    else:
        totals['energy_out_kwh'] = round(totals.get('energy_out_kwh', 0) + abs(delta_kwh), 3)

    totals_map[alias_key] = totals
    try:
        with open(file_path, 'w') as fp:
            json.dump(totals_map, fp)
    except OSError:
        pass

    data.update(totals)

def combine_battery_readings(data_map):
    """Combine up to eight battery readings into a single dictionary.

    Calculates cumulative capacity, remaining charge, power, current and
    charge percentage across all provided batteries.
    """
    combined = {"device_id": "combined"}
    if len(data_map) > 8:
        raise ValueError("combine_battery_readings supports up to 8 batteries")
    total_capacity = 0
    total_remaining = 0
    total_power = 0
    total_current = 0
    total_energy_in = 0
    total_energy_out = 0

    for dev_id, d in data_map.items():
        capacity = d.get("capacity") or 0
        remaining = d.get("remaining_charge") or 0
        power = d.get("power") or 0
        current = d.get("current") or 0
        energy_in = d.get("energy_in_kwh") or 0
        energy_out = d.get("energy_out_kwh") or 0

        total_capacity += capacity
        total_remaining += remaining
        total_power += power
        total_current += current
        total_energy_in += energy_in
        total_energy_out += energy_out

        cells = [v for k, v in d.items() if k.startswith("cell_voltage_") and isinstance(v, (int, float))]
        if cells:
            combined[f"battery_{dev_id}_cell_voltage_min"] = min(cells)
            combined[f"battery_{dev_id}_cell_voltage_max"] = max(cells)

        temps = [v for k, v in d.items() if k.startswith("temperature_") and isinstance(v, (int, float))]
        if temps:
            combined[f"battery_{dev_id}_temperature_min"] = min(temps)
            combined[f"battery_{dev_id}_temperature_max"] = max(temps)

    combined["combined_capacity"] = round(total_capacity, 3)
    combined["combined_remaining_charge"] = round(total_remaining, 3)
    combined["combined_power"] = round(total_power, 2)
    combined["combined_current"] = round(total_current, 2)
    combined["combined_energy_in_kwh"] = round(total_energy_in, 3)
    combined["combined_energy_out_kwh"] = round(total_energy_out, 3)
    if total_capacity:
        combined["combined_charge_percentage"] = round((total_remaining / total_capacity) * 100, 2)

    return combined

CRC16_LOW_BYTES = (
    0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7, 0x05, 0xC5, 0xC4, 0x04,
    0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E, 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 0x08, 0xC8,
    0xD8, 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC,
    0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3, 0x11, 0xD1, 0xD0, 0x10,
    0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32, 0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4,
    0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A, 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38,
    0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF, 0x2D, 0xED, 0xEC, 0x2C,
    0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26, 0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0,
    0xA0, 0x60, 0x61, 0xA1, 0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4,
    0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB, 0x69, 0xA9, 0xA8, 0x68,
    0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA, 0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C,
    0xB4, 0x74, 0x75, 0xB5, 0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0,
    0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54,
    0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98,
    0x88, 0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
    0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 0x40
)

CRC16_HIGH_BYTES = (
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
    0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
    0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
    0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
    0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
    0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
    0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
    0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
    0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
)

# Calculate CRC-16 for Modbus
def crc16_modbus(data: bytes):
    crc_high = 0xFF
    crc_low = 0xFF

    for byte in data:
        index = crc_high ^ int(byte)
        crc_high = crc_low ^ CRC16_HIGH_BYTES[index]
        crc_low = CRC16_LOW_BYTES[index]

    return bytes([crc_high, crc_low])
